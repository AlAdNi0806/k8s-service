/cmd/main.go

```go
package main

import (
	"auth-service/internal/config"
	"auth-service/internal/handler"
	authmw "auth-service/internal/middleware"
	"auth-service/internal/repository"
	"auth-service/internal/service"
	"auth-service/internal/utils"
	"context"
	"database/sql"
	"errors"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"time"

	_ "github.com/go-sql-driver/mysql"
	"github.com/labstack/echo-contrib/prometheus"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"

	// OpenTelemetry Imports
	"go.opentelemetry.io/contrib/instrumentation/github.com/labstack/echo/otelecho"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/exporters/stdout/stdouttrace"
	"go.opentelemetry.io/otel/sdk/resource"
	"go.opentelemetry.io/otel/sdk/trace"
	semconv "go.opentelemetry.io/otel/semconv/v1.26.0"

	"github.com/redis/go-redis/v9"
)

const serviceName = "auth-service"
const serviceVersion = "1.0.0"

// setupOTelSDK initializes the OpenTelemetry SDK.
// It returns a function to call to shut down the tracer and an error if one occurs.
func setupOTelSDK(ctx context.Context) (cleanup func(context.Context) error, err error) {
	var shutdownFuncs []func(context.Context) error

	// cleanup is a helper function to ensure all shutdown functions are called
	cleanup = func(ctx context.Context) error {
		var err error
		for _, fn := range shutdownFuncs {
			err = errors.Join(err, fn(ctx))
		}
		shutdownFuncs = nil
		return err
	}

	// handleErr calls cleanup and stores the error.
	handleErr := func(inErr error) {
		err = errors.Join(inErr, cleanup(ctx))
	}

	// --- 1. Resource ---
	res, err := resource.Merge(
		resource.Default(),
		resource.NewWithAttributes(
			semconv.SchemaURL,
			semconv.ServiceNameKey.String(serviceName),
			semconv.ServiceVersionKey.String(serviceVersion),
			attribute.String("environment", "development"), // Customize environment
		),
	)
	if err != nil {
		handleErr(fmt.Errorf("failed to create resource: %w", err))
		return
	}

	// --- 2. Tracer Provider/Exporter (using stdout for simplicity) ---
	// Create stdout exporter to be able to see the traces.
	traceExporter, err := stdouttrace.New(stdouttrace.WithPrettyPrint())
	if err != nil {
		handleErr(fmt.Errorf("failed to create trace exporter: %w", err))
		return
	}

	// Create the TracerProvider.
	bsp := trace.NewBatchSpanProcessor(traceExporter)
	tracerProvider := trace.NewTracerProvider(
		trace.WithSampler(trace.AlwaysSample()),
		trace.WithResource(res),
		trace.WithSpanProcessor(bsp),
	)
	shutdownFuncs = append(shutdownFuncs, tracerProvider.Shutdown)

	// Set the global TracerProvider
	otel.SetTracerProvider(tracerProvider)

	// Note: For full metrics and logs support, you'd add MeterProvider and LoggerProvider here.

	return
}

func main() {
	// Setup OpenTelemetry SDK (Traces, Metrics, Logs)
	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
	defer stop()

	otelShutdown, err := setupOTelSDK(ctx)
	if err != nil {
		log.Fatalf("Error setting up OpenTelemetry SDK: %v", err)
	}
	// Call cleanup on exit to ensure all spans/metrics are flushed
	defer func() {
		err = errors.Join(err, otelShutdown(context.Background()))
		if err != nil {
			log.Fatalf("Error shutting down OpenTelemetry: %v", err)
		}
	}()
	// End of OTel Setup

	// --- Your existing application logic starts here ---

	cfg := config.Load()
	utils.InitJWT(cfg.JWTSecret)

	// Подключение к MariaDB (Consider instrumenting your SQL connection)
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?parseTime=true",
		cfg.DBUser,
		cfg.DBPassword,
		cfg.DBHost,
		cfg.DBPort,
		cfg.DBName,
	)

	db, err := sql.Open("mysql", dsn)
	if err != nil {
		log.Fatal("Failed to connect to DB:", err)
	}
	defer db.Close()

	if err := db.Ping(); err != nil {
		log.Fatal("Failed to ping DB:", err)
	}

	// Подключение к Redis (Consider instrumenting your Redis client)
	redisClient := redis.NewClient(&redis.Options{Addr: cfg.RedisAddr})
	defer redisClient.Close()

	// Инициализация сервисов
	userRepo := repository.NewUserRepository(db)
	authService := service.NewAuthService(userRepo, redisClient)

	// Echo
	e := echo.New()

	// ⭐️ ADD OPENTELEMETRY MIDDLEWARE HERE ⭐️
	e.Use(otelecho.Middleware(serviceName,
		// You can optionally skip tracing for certain endpoints like health checks
		otelecho.WithSkipper(func(c echo.Context) bool {
			return c.Path() == "/health" || c.Path() == "/metrics"
		}),
	))

	// Middleware: логирование (включает IP)
	e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
		Format: `{"time":"${time_rfc3339}", "method":"${method}", "uri":"${uri}", "status":${status}, "latency":"${latency_human}", "ip":"${remote_ip}"}` + "\n",
	}))
	e.Use(middleware.Recover())

	// Prometheus middleware — ДОБАВЛЕНО
	p := prometheus.NewPrometheus("echo", nil)
	p.Use(e) // регистрирует /metrics

	// Роуты
	authHandler := handler.NewAuthHandler(authService)
	e.POST("/register", authHandler.Register)
	e.POST("/login", authHandler.Login)

	// Защищённый эндпоинт
	e.GET("/me", func(c echo.Context) error {
		return c.JSON(http.StatusOK, map[string]string{"message": "Authenticated!"})
	}, authmw.AuthMiddleware(authService))

	// Health-check (Skipped from tracing via WithSkipper above)
	e.GET("/health", func(c echo.Context) error {
		return c.JSON(http.StatusOK, map[string]string{"status": "ok"})
	})

	// Порт
	port := "8081"
	if p := os.Getenv("PORT"); p != "" {
		port = p
	}
	addr := ":" + port

	log.Printf("Auth service starting on %s", addr)

	// Use the graceful shutdown context for Echo's Start as well
	if err := e.Start(addr); err != nil && !errors.Is(err, http.ErrServerClosed) {
		log.Fatal(err)
	}

	// Wait for an interrupt signal for graceful shutdown (like your initial example)
	<-ctx.Done()
	log.Println("Shutting down gracefully...")

	// Perform graceful shutdown of the Echo server
	shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	if err := e.Shutdown(shutdownCtx); err != nil {
		log.Fatal("Echo server Shutdown error:", err)
	}
	log.Println("Echo server shut down.")
}
```

/internal/config/config.go

```go
package config

import "os"

type Config struct {
	DBHost     string
	DBPort     string
	DBUser     string
	DBPassword string
	DBName     string

	RedisAddr string

	JWTSecret string

	OtelExporterURL string
}

func Load() *Config {
	return &Config{
		DBHost:     getEnv("DB_HOST", "192.168.0.176"),
		DBPort:     getEnv("DB_PORT", "3306"),
		DBUser:     getEnv("DB_USER", "auth_user"),
		DBPassword: getEnv("DB_PASSWORD", "auth_pass"),
		DBName:     getEnv("DB_NAME", "auth_db"),

		RedisAddr: getEnv("REDIS_ADDR", "192.168.0.176:6379"),

		JWTSecret: getEnv("JWT_SECRET", "super-secret-jwt-key"),

		OtelExporterURL: getEnv("OTEL_EXPORTER_OTLP_ENDPOINT", "http://192.168.0.176:4318"),
	}
}

func getEnv(key, fallback string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return fallback
}
```

/internal/handler/auth.go

```go
// internal/handler/auth.go
package handler

import (
	"auth-service/internal/service"
	"net/http"

	"github.com/labstack/echo/v4"
)

type AuthHandler struct {
	authService *service.AuthService
}

func NewAuthHandler(authService *service.AuthService) *AuthHandler {
	return &AuthHandler{authService: authService}
}

func (h *AuthHandler) Register(c echo.Context) error {
	type Request struct {
		Email    string `json:"email"`
		Password string `json:"password"`
	}

	req := new(Request)
	if err := c.Bind(req); err != nil {
		return echo.ErrBadRequest
	}

	if err := h.authService.Register(c.Request().Context(), req.Email, req.Password); err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	return c.JSON(http.StatusCreated, map[string]string{"message": "User registered"})
}

func (h *AuthHandler) Login(c echo.Context) error {
	type Request struct {
		Email    string `json:"email"`
		Password string `json:"password"`
	}

	req := new(Request)
	if err := c.Bind(req); err != nil {
		return echo.ErrBadRequest
	}

	token, err := h.authService.Login(c.Request().Context(), req.Email, req.Password)
	if err != nil {
		return echo.ErrUnauthorized
	}

	return c.JSON(http.StatusOK, map[string]string{"token": token})
}
```

/internal/middleware/auth.go

```go
// internal/middleware/auth.go
package middleware

import (
	"auth-service/internal/service"
	"strings"

	"github.com/labstack/echo/v4"
)

func AuthMiddleware(authService *service.AuthService) echo.MiddlewareFunc {
	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			authHeader := c.Request().Header.Get("Authorization")
			if authHeader == "" {
				return echo.ErrUnauthorized
			}

			parts := strings.Split(authHeader, " ")
			if len(parts) != 2 || parts[0] != "Bearer" {
				return echo.ErrUnauthorized
			}

			token := parts[1]
			_, err := authService.ValidateToken(c.Request().Context(), token)
			if err != nil {
				return echo.ErrUnauthorized
			}

			return next(c)
		}
	}
}
```

/internal/model/user.go

```go
// internal/model/user.go
package model

type User struct {
	ID       int64
	Email    string
	Password string
}
```

/internal/repository/mariadb.go

```go
// internal/repository/mariadb.go
package repository

import (
	"database/sql"
	"fmt"

	"auth-service/internal/model"

	_ "github.com/go-sql-driver/mysql"
)

type UserRepository struct {
	db *sql.DB
}

func NewUserRepository(db *sql.DB) *UserRepository {
	return &UserRepository{db: db}
}

func (r *UserRepository) Create(email, password string) error {
	_, err := r.db.Exec("INSERT INTO users (email, password) VALUES (?, ?)", email, password)
	return err
}

func (r *UserRepository) FindByEmail(email string) (*model.User, error) {
	user := &model.User{}
	err := r.db.QueryRow("SELECT id, email, password FROM users WHERE email = ?", email).
		Scan(&user.ID, &user.Email, &user.Password)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user not found")
		}
		return nil, err
	}
	return user, nil
}
```

/internal/service/auth.go

```go
// internal/service/auth.go
package service

import (
	"auth-service/internal/repository"
	"auth-service/internal/utils"
	"context"
	"crypto/rand"
	"encoding/hex"
	"time"

	"github.com/redis/go-redis/v9"
	"golang.org/x/crypto/bcrypt"
)

type AuthService struct {
	userRepo *repository.UserRepository
	redis    *redis.Client
}

func NewAuthService(userRepo *repository.UserRepository, redis *redis.Client) *AuthService {
	return &AuthService{userRepo: userRepo, redis: redis}
}

// Register — регистрирует пользователя
func (s *AuthService) Register(ctx context.Context, email, password string) error {
	hashed, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return err
	}
	return s.userRepo.Create(email, string(hashed))
}

// Login — аутентифицирует и возвращает JWT-токен
func (s *AuthService) Login(ctx context.Context, email, password string) (string, error) {
	user, err := s.userRepo.FindByEmail(email)
	if err != nil {
		return "", err
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil {
		return "", err
	}

	token, err := utils.GenerateToken(user.ID)
	if err != nil {
		return "", err
	}

	// Генерируем уникальный ключ для хранения в Redis
	tokenKey := "token:" + generateTokenID()
	err = s.redis.Set(ctx, tokenKey, user.ID, 24*time.Hour).Err()
	if err != nil {
		return "", err
	}

	// Сохраняем связь токен → ключ (для отзыва)
	err = s.redis.Set(ctx, "user_token:"+token, tokenKey, 24*time.Hour).Err()
	if err != nil {
		// Опционально: удалить tokenKey при ошибке
		s.redis.Del(ctx, tokenKey)
		return "", err
	}

	return token, nil
}

// ValidateToken — проверяет валидность токена через JWT + Redis
func (s *AuthService) ValidateToken(ctx context.Context, token string) (int64, error) {
	userID, err := utils.ValidateToken(token)
	if err != nil {
		return 0, err
	}

	tokenKey, err := s.redis.Get(ctx, "user_token:"+token).Result()
	if err != nil {
		return 0, err // токен не найден → недействителен
	}

	storedUserID, err := s.redis.Get(ctx, tokenKey).Int64()
	if err != nil {
		return 0, err
	}
	if storedUserID != userID {
		return 0, err
	}

	return userID, nil
}

func generateTokenID() string {
	bytes := make([]byte, 16)
	rand.Read(bytes)
	return hex.EncodeToString(bytes)
}
```

/internal/utils/jwt.go

```go
package utils

import (
	"fmt"
	"time"

	"github.com/golang-jwt/jwt/v5"
)

var jwtKey []byte

func InitJWT(secret string) {
	jwtKey = []byte(secret)
}

func GenerateToken(userID int64) (string, error) {
	claims := jwt.MapClaims{
		"user_id": userID,
		"exp":     time.Now().Add(24 * time.Hour).Unix(),
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString(jwtKey)
}

func ValidateToken(tokenString string) (int64, error) {
	claims := jwt.MapClaims{}
	token, err := jwt.ParseWithClaims(tokenString, claims, func(t *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil || !token.Valid {
		return 0, err
	}

	if userID, ok := claims["user_id"].(float64); ok {
		return int64(userID), nil
	}
	return 0, fmt.Errorf("invalid user_id in token")
}
```

/internal/utils/otel.go

```go
package main

import (
	"context"
	"errors"
	"time"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/exporters/stdout/stdoutlog"
	"go.opentelemetry.io/otel/exporters/stdout/stdoutmetric"
	"go.opentelemetry.io/otel/exporters/stdout/stdouttrace"
	"go.opentelemetry.io/otel/log/global"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/sdk/log"
	"go.opentelemetry.io/otel/sdk/metric"
	"go.opentelemetry.io/otel/sdk/trace"
)

// setupOTelSDK bootstraps the OpenTelemetry pipeline.
// If it does not return an error, make sure to call shutdown for proper cleanup.
func setupOTelSDK(ctx context.Context) (func(context.Context) error, error) {
	var shutdownFuncs []func(context.Context) error
	var err error

	// shutdown calls cleanup functions registered via shutdownFuncs.
	// The errors from the calls are joined.
	// Each registered cleanup will be invoked once.
	shutdown := func(ctx context.Context) error {
		var err error
		for _, fn := range shutdownFuncs {
			err = errors.Join(err, fn(ctx))
		}
		shutdownFuncs = nil
		return err
	}

	// handleErr calls shutdown for cleanup and makes sure that all errors are returned.
	handleErr := func(inErr error) {
		err = errors.Join(inErr, shutdown(ctx))
	}

	// Set up propagator.
	prop := newPropagator()
	otel.SetTextMapPropagator(prop)

	// Set up trace provider.
	tracerProvider, err := newTracerProvider()
	if err != nil {
		handleErr(err)
		return shutdown, err
	}
	shutdownFuncs = append(shutdownFuncs, tracerProvider.Shutdown)
	otel.SetTracerProvider(tracerProvider)

	// Set up meter provider.
	meterProvider, err := newMeterProvider()
	if err != nil {
		handleErr(err)
		return shutdown, err
	}
	shutdownFuncs = append(shutdownFuncs, meterProvider.Shutdown)
	otel.SetMeterProvider(meterProvider)

	// Set up logger provider.
	loggerProvider, err := newLoggerProvider()
	if err != nil {
		handleErr(err)
		return shutdown, err
	}
	shutdownFuncs = append(shutdownFuncs, loggerProvider.Shutdown)
	global.SetLoggerProvider(loggerProvider)

	return shutdown, err
}

func newPropagator() propagation.TextMapPropagator {
	return propagation.NewCompositeTextMapPropagator(
		propagation.TraceContext{},
		propagation.Baggage{},
	)
}

func newTracerProvider() (*trace.TracerProvider, error) {
	traceExporter, err := stdouttrace.New(
		stdouttrace.WithPrettyPrint())
	if err != nil {
		return nil, err
	}

	tracerProvider := trace.NewTracerProvider(
		trace.WithBatcher(traceExporter,
			// Default is 5s. Set to 1s for demonstrative purposes.
			trace.WithBatchTimeout(time.Second)),
	)
	return tracerProvider, nil
}

func newMeterProvider() (*metric.MeterProvider, error) {
	metricExporter, err := stdoutmetric.New()
	if err != nil {
		return nil, err
	}

	meterProvider := metric.NewMeterProvider(
		metric.WithReader(metric.NewPeriodicReader(metricExporter,
			// Default is 1m. Set to 3s for demonstrative purposes.
			metric.WithInterval(3*time.Second))),
	)
	return meterProvider, nil
}

func newLoggerProvider() (*log.LoggerProvider, error) {
	logExporter, err := stdoutlog.New()
	if err != nil {
		return nil, err
	}

	loggerProvider := log.NewLoggerProvider(
		log.WithProcessor(log.NewBatchProcessor(logExporter)),
	)
	return loggerProvider, nil
}
```

