/cmd/main.go

```go
package main

import (
	"auth-service/internal/config"
	"auth-service/internal/handler"
	authmw "auth-service/internal/middleware"
	"auth-service/internal/repository"
	"auth-service/internal/service"
	"auth-service/internal/utils"
	"context"
	"database/sql"
	"errors"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"time"

	_ "github.com/go-sql-driver/mysql"
	"github.com/labstack/echo-contrib/prometheus"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"

	// OpenTelemetry Imports
	"go.opentelemetry.io/contrib/instrumentation/github.com/labstack/echo/otelecho"

	"github.com/redis/go-redis/v9"
)

const serviceName = "auth-service"
const serviceVersion = "1.0.0"

func main() {
	// Setup OpenTelemetry SDK (Traces, Metrics, Logs)
	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
	defer stop()

	cfg := config.Load()

	otelShutdown, err := utils.SetupOTelSDK(ctx, serviceName, serviceVersion, cfg.OtelExporterURL)
	if err != nil {
		log.Fatalf("Error setting up OpenTelemetry SDK: %v", err)
	}
	// Call cleanup on exit to ensure all spans/metrics are flushed
	defer func() {
		err = errors.Join(err, otelShutdown(context.Background()))
		if err != nil {
			log.Fatalf("Error shutting down OpenTelemetry: %v", err)
		}
	}()
	// End of OTel Setup

	// --- Your existing application logic starts here ---

	utils.InitJWT(cfg.JWTSecret)

	// Подключение к MariaDB (Consider instrumenting your SQL connection)
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?parseTime=true",
		cfg.DBUser,
		cfg.DBPassword,
		cfg.DBHost,
		cfg.DBPort,
		cfg.DBName,
	)

	db, err := sql.Open("mysql", dsn)
	if err != nil {
		log.Fatal("Failed to connect to DB:", err)
	}
	defer db.Close()

	if err := db.Ping(); err != nil {
		log.Fatal("Failed to ping DB:", err)
	}

	// Подключение к Redis (Consider instrumenting your Redis client)
	redisClient := redis.NewClient(&redis.Options{Addr: cfg.RedisAddr, Password: cfg.RedisPassword})
	defer redisClient.Close()

	if _, err := redisClient.Ping(context.Background()).Result(); err != nil {
		logger := utils.NewHelperLogger("auth-service.service.general")
		logger.LogError(ctx, "Could not get into redis", err)
	}

	// Инициализация сервисов
	userRepo := repository.NewUserRepository(db)
	authService := service.NewAuthService(userRepo, redisClient)

	// Echo
	e := echo.New()

	// ⭐️ ADD OPENTELEMETRY MIDDLEWARE HERE ⭐️
	e.Use(otelecho.Middleware(serviceName,
		// You can optionally skip tracing for certain endpoints like health checks
		otelecho.WithSkipper(func(c echo.Context) bool {
			return c.Path() == "/health" || c.Path() == "/metrics"
		}),
	))

	// Middleware: логирование (включает IP)
	e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
		Format: `{"time":"${time_rfc3339}", "method":"${method}", "uri":"${uri}", "status":${status}, "latency":"${latency_human}", "ip":"${remote_ip}"}` + "\n",
	}))
	// e.Use(middleware.Recover())

	// Prometheus middleware — ДОБАВЛЕНО
	p := prometheus.NewPrometheus("echo", nil)
	p.Use(e) // регистрирует /metrics

	// Роуты
	authHandler := handler.NewAuthHandler(authService)
	e.POST("/register", authHandler.Register)
	e.POST("/login", authHandler.Login)

	// Защищённый эндпоинт
	e.GET("/me", func(c echo.Context) error {
		return c.JSON(http.StatusOK, map[string]string{"message": "Authenticated!"})
	}, authmw.AuthMiddleware(authService))

	// Health-check (Skipped from tracing via WithSkipper above)
	e.GET("/health", func(c echo.Context) error {
		return c.JSON(http.StatusOK, map[string]string{"status": "ok"})
	})

	// Порт
	port := "8081"
	if p := os.Getenv("PORT"); p != "" {
		port = p
	}
	addr := ":" + port

	log.Printf("Auth service starting on %s", addr)

	// Use the graceful shutdown context for Echo's Start as well
	if err := e.Start(addr); err != nil && !errors.Is(err, http.ErrServerClosed) {
		log.Fatal(err)
	}

	// Wait for an interrupt signal for graceful shutdown (like your initial example)
	<-ctx.Done()
	log.Println("Shutting down gracefully...")

	// Perform graceful shutdown of the Echo server
	shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	if err := e.Shutdown(shutdownCtx); err != nil {
		log.Fatal("Echo server Shutdown error:", err)
	}
	log.Println("Echo server shut down.")
}
```

/internal/config/config.go

```go
package config

import "os"

type Config struct {
	DBHost     string
	DBPort     string
	DBUser     string
	DBPassword string
	DBName     string

	RedisAddr     string
	RedisPassword string

	JWTSecret string

	OtelExporterURL string
}

func Load() *Config {
	return &Config{
		DBHost:     getEnv("DB_HOST", "192.168.0.176"),
		DBPort:     getEnv("DB_PORT", "3306"),
		DBUser:     getEnv("DB_USER", "auth_user"),
		DBPassword: getEnv("DB_PASSWORD", "auth_pass"),
		DBName:     getEnv("DB_NAME", "auth_db"),

		RedisAddr:     getEnv("REDIS_ADDR", "192.168.0.176:6379"),
		RedisPassword: getEnv("REDIS_PASSWORD", "2Uve6YlxN7"),

		JWTSecret: getEnv("JWT_SECRET", "super-secret-jwt-key"),

		OtelExporterURL: getEnv("OTEL_EXPORTER_OTLP_ENDPOINT", "192.168.0.176:4317"),
	}
}

func getEnv(key, fallback string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return fallback
}
```

/internal/handler/auth.go

```go
// internal/handler/auth.go
package handler

import (
	"auth-service/internal/service"
	"fmt"
	"net/http"

	"github.com/labstack/echo/v4"
)

type AuthHandler struct {
	authService *service.AuthService
}

func NewAuthHandler(authService *service.AuthService) *AuthHandler {
	return &AuthHandler{authService: authService}
}

func (h *AuthHandler) Register(c echo.Context) error {
	type Request struct {
		Email    string `json:"email"`
		Password string `json:"password"`
	}

	req := new(Request)
	if err := c.Bind(req); err != nil {
		return echo.ErrBadRequest
	}

	if err := h.authService.Register(c.Request().Context(), req.Email, req.Password); err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	return c.JSON(http.StatusCreated, map[string]string{"message": "User registered"})
}

func (h *AuthHandler) Login(c echo.Context) error {
	type Request struct {
		Email    string `json:"email"`
		Password string `json:"password"`
	}

	req := new(Request)
	if err := c.Bind(req); err != nil {
		fmt.Println(err)
		return echo.ErrBadRequest
	}

	token, err := h.authService.Login(c.Request().Context(), req.Email, req.Password)
	if err != nil {
		return echo.ErrUnauthorized
	}

	return c.JSON(http.StatusOK, map[string]string{"token": token})
}
```

/internal/middleware/auth.go

```go
// internal/middleware/auth.go
package middleware

import (
	"auth-service/internal/service"
	"strings"

	"github.com/labstack/echo/v4"
)

func AuthMiddleware(authService *service.AuthService) echo.MiddlewareFunc {
	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			authHeader := c.Request().Header.Get("Authorization")
			if authHeader == "" {
				return echo.ErrUnauthorized
			}

			parts := strings.Split(authHeader, " ")
			if len(parts) != 2 || parts[0] != "Bearer" {
				return echo.ErrUnauthorized
			}

			token := parts[1]
			_, err := authService.ValidateToken(c.Request().Context(), token)
			if err != nil {
				return echo.ErrUnauthorized
			}

			return next(c)
		}
	}
}
```

/internal/model/user.go

```go
// internal/model/user.go
package model

type User struct {
	ID       int64
	Email    string
	Password string
}
```

/internal/repository/mariadb.go

```go
// internal/repository/mariadb.go
package repository

import (
	"database/sql"
	"fmt"

	"auth-service/internal/model"

	_ "github.com/go-sql-driver/mysql"
)

type UserRepository struct {
	db *sql.DB
}

func NewUserRepository(db *sql.DB) *UserRepository {
	return &UserRepository{db: db}
}

func (r *UserRepository) Create(email, password string) error {
	_, err := r.db.Exec("INSERT INTO users (email, password) VALUES (?, ?)", email, password)
	return err
}

func (r *UserRepository) FindByEmail(email string) (*model.User, error) {
	user := &model.User{}
	err := r.db.QueryRow("SELECT id, email, password FROM users WHERE email = ?", email).
		Scan(&user.ID, &user.Email, &user.Password)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user not found")
		}
		return nil, err
	}
	return user, nil
}
```

/internal/service/auth.go

```go
// internal/service/auth.go
package service

import (
	"auth-service/internal/repository"
	"auth-service/internal/utils"
	"context"
	"crypto/rand"
	"encoding/hex"
	"time"

	"github.com/redis/go-redis/v9"
	"go.opentelemetry.io/otel/log"
	"golang.org/x/crypto/bcrypt"
)

type AuthService struct {
	userRepo *repository.UserRepository
	redis    *redis.Client
}

func NewAuthService(userRepo *repository.UserRepository, redis *redis.Client) *AuthService {
	return &AuthService{userRepo: userRepo, redis: redis}
}

// Register — регистрирует пользователя
func (s *AuthService) Register(ctx context.Context, email, password string) error {
	logger := utils.NewHelperLogger("auth-service.service.register")
	hashed, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return err
	}

	err = s.userRepo.Create(email, string(hashed))

	if err != nil {
		logger.LogError(ctx, "User not found during login attempt", err,
			log.KeyValue{Key: "email", Value: log.StringValue(email)},
		)
		return err
	}

	logger.LogInfo(ctx, "User not found during login attempt",
		log.KeyValue{Key: "email", Value: log.StringValue(email)},
	)

	return err
}

// Login — аутентифицирует и возвращает JWT-токен
func (s *AuthService) Login(ctx context.Context, email, password string) (string, error) {
	logger := utils.NewHelperLogger("auth-service.service.login")

	user, err := s.userRepo.FindByEmail(email)
	if err != nil {
		logger.LogError(ctx, "User not found during login attempt", err,
			log.KeyValue{Key: "email", Value: log.StringValue(email)},
		)
		return "", err
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil {
		logger.LogError(ctx, "User not found during login attempt", err,
			log.KeyValue{Key: "email", Value: log.StringValue(email)},
			log.KeyValue{Key: "user.id", Value: log.Int64Value(user.ID)},
			log.KeyValue{Key: "error", Value: log.StringValue(err.Error())},
		)
		return "", err
	}

	token, err := utils.GenerateToken(user.ID)
	if err != nil {
		logger.LogError(ctx, "Failed to generate token", err,
			log.KeyValue{Key: "email", Value: log.StringValue(email)},
		)
		return "", err
	}

	// Генерируем уникальный ключ для хранения в Redis
	tokenKey := "token:" + generateTokenID()
	err = s.redis.Set(ctx, tokenKey, user.ID, 24*time.Hour).Err()
	if err != nil {
		logger.LogError(ctx, "Could not store token in Redis", err,
			log.KeyValue{Key: "email", Value: log.StringValue(email)},
		)
		return "", err
	}

	// Сохраняем связь токен → ключ (для отзыва)
	err = s.redis.Set(ctx, "user_token:"+token, tokenKey, 24*time.Hour).Err()
	if err != nil {
		logger.LogError(ctx, "Could not store token in Redis _2", err,
			log.KeyValue{Key: "email", Value: log.StringValue(email)},
		)
		// Опционально: удалить tokenKey при ошибке
		s.redis.Del(ctx, tokenKey)
		return "", err
	}

	return token, nil
}

// ValidateToken — проверяет валидность токена через JWT + Redis
func (s *AuthService) ValidateToken(ctx context.Context, token string) (int64, error) {
	userID, err := utils.ValidateToken(token)
	if err != nil {
		return 0, err
	}

	tokenKey, err := s.redis.Get(ctx, "user_token:"+token).Result()
	if err != nil {
		return 0, err // токен не найден → недействителен
	}

	storedUserID, err := s.redis.Get(ctx, tokenKey).Int64()
	if err != nil {
		return 0, err
	}
	if storedUserID != userID {
		return 0, err
	}

	return userID, nil
}

func generateTokenID() string {
	bytes := make([]byte, 16)
	rand.Read(bytes)
	return hex.EncodeToString(bytes)
}
```

/internal/utils/jwt.go

```go
package utils

import (
	"fmt"
	"time"

	"github.com/golang-jwt/jwt/v5"
)

var jwtKey []byte

func InitJWT(secret string) {
	jwtKey = []byte(secret)
}

func GenerateToken(userID int64) (string, error) {
	claims := jwt.MapClaims{
		"user_id": userID,
		"exp":     time.Now().Add(24 * time.Hour).Unix(),
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString(jwtKey)
}

func ValidateToken(tokenString string) (int64, error) {
	claims := jwt.MapClaims{}
	token, err := jwt.ParseWithClaims(tokenString, claims, func(t *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil || !token.Valid {
		return 0, err
	}

	if userID, ok := claims["user_id"].(float64); ok {
		return int64(userID), nil
	}
	return 0, fmt.Errorf("invalid user_id in token")
}
```

/internal/utils/log.go

```go
package utils

import (
	"context"

	"go.opentelemetry.io/otel/log"
	"go.opentelemetry.io/otel/log/global"
)

// HelperLogger is a wrapper around the global OpenTelemetry logger.
type HelperLogger struct {
	logger log.Logger
}

// NewHelperLogger creates a new logger instance with a specific name.
func NewHelperLogger(name string) HelperLogger {
	return HelperLogger{
		logger: global.Logger(name),
	}
}

// LogInfo emits an INFO level log event.
func (h HelperLogger) LogInfo(ctx context.Context, message string, attributes ...log.KeyValue) {
	h.emit(ctx, log.SeverityInfo, message, attributes)
}

// LogWarn emits a WARN level log event.
func (h HelperLogger) LogWarn(ctx context.Context, message string, attributes ...log.KeyValue) {
	h.emit(ctx, log.SeverityWarn, message, attributes)
}

// LogError emits an ERROR level log event.
func (h HelperLogger) LogError(ctx context.Context, message string, err error, attributes ...log.KeyValue) {
	// Add the error object itself as the final attribute
	if err != nil {
		attributes = append(attributes, log.KeyValue{Key: "error", Value: log.StringValue(err.Error())})
	}
	h.emit(ctx, log.SeverityError, message, attributes)
}

// emit creates and emits the log.Record. This is the core helper logic.
func (h HelperLogger) emit(ctx context.Context, severity log.Severity, message string, attributes []log.KeyValue) {
	record := log.Record{}
	record.SetBody(log.StringValue(message))
	record.SetSeverity(severity)

	// Add time for completeness, though the exporter usually handles this
	record.SetTimestamp(record.Timestamp())

	// Add attributes
	record.AddAttributes(attributes...)

	h.logger.Emit(ctx, record)
}
```

/internal/utils/otel.go

```go
package utils

import (
	"context"
	"errors"
	"fmt" // ⭐️ Added for resource setup error formatting
	"time"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/exporters/otlp/otlplog/otlploggrpc"       // ⭐️ NEW: OTLP Log Exporter
	"go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc" // ⭐️ NEW: OTLP Metric Exporter
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"   // ⭐️ NEW: OTLP Trace Exporter
	"go.opentelemetry.io/otel/log/global"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/sdk/log"
	"go.opentelemetry.io/otel/sdk/metric"
	"go.opentelemetry.io/otel/sdk/resource"
	"go.opentelemetry.io/otel/sdk/trace"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"

	// ⭐️ NEW: Dependencies for gRPC
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

// SetupOTelSDK bootstraps the OpenTelemetry pipeline and sends data via OTLP.
func SetupOTelSDK(ctx context.Context, serviceName, serviceVersion, otelExporterURL string) (func(context.Context) error, error) { // ⭐️ CHANGED: Added otelExporterURL
	var shutdownFuncs []func(context.Context) error
	var err error

	// shutdown calls cleanup functions registered via shutdownFuncs.
	shutdown := func(ctx context.Context) error {
		var err error
		for _, fn := range shutdownFuncs {
			err = errors.Join(err, fn(ctx))
		}
		shutdownFuncs = nil
		return err
	}

	// handleErr calls shutdown for cleanup and makes sure that all errors are returned.
	handleErr := func(inErr error) {
		err = errors.Join(inErr, shutdown(ctx))
	}

	// --- 1. Resource: Define service attributes ---
	res, err := resource.Merge(
		resource.Default(),
		resource.NewWithAttributes(
			semconv.SchemaURL,
			semconv.ServiceNameKey.String(serviceName),
			semconv.ServiceVersionKey.String(serviceVersion),
			attribute.String("environment", "development"),
		),
	)
	if err != nil {
		handleErr(fmt.Errorf("failed to create resource: %w", err))
		return shutdown, err
	}

	// Set up propagator.
	prop := newPropagator()
	otel.SetTextMapPropagator(prop)

	// --- GRPC Connection for OTLP Exporters (SigNoz typically uses 4317 for gRPC) ---
	// NOTE: Using insecure for simplicity, use TLS for production.
	conn, err := grpc.NewClient(otelExporterURL,
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	)
	if err != nil {
		handleErr(fmt.Errorf("failed to create gRPC connection to collector: %w", err))
		return shutdown, err
	}
	shutdownFuncs = append(shutdownFuncs, func(ctx context.Context) error {
		return conn.Close()
	})

	// Set up trace provider.
	tracerProvider, err := newTracerProvider(ctx, res, conn) // ⭐️ PASS CONN
	if err != nil {
		handleErr(err)
		return shutdown, err
	}
	shutdownFuncs = append(shutdownFuncs, tracerProvider.Shutdown)
	otel.SetTracerProvider(tracerProvider)

	// Set up meter provider.
	meterProvider, err := newMeterProvider(ctx, res, conn) // ⭐️ PASS CONN
	if err != nil {
		handleErr(err)
		return shutdown, err
	}
	shutdownFuncs = append(shutdownFuncs, meterProvider.Shutdown)
	otel.SetMeterProvider(meterProvider)

	// Set up logger provider.
	loggerProvider, err := newLoggerProvider(ctx, res, conn) // ⭐️ PASS CONN
	if err != nil {
		handleErr(err)
		return shutdown, err
	}
	shutdownFuncs = append(shutdownFuncs, loggerProvider.Shutdown)
	global.SetLoggerProvider(loggerProvider)

	return shutdown, err
}

func newPropagator() propagation.TextMapPropagator {
	return propagation.NewCompositeTextMapPropagator(
		propagation.TraceContext{},
		propagation.Baggage{},
	)
}

// ⭐️ UPDATED signature to accept context and gRPC connection
func newTracerProvider(ctx context.Context, res *resource.Resource, conn *grpc.ClientConn) (*trace.TracerProvider, error) {
	// ⭐️ OTLP Trace Exporter
	traceExporter, err := otlptracegrpc.New(ctx, otlptracegrpc.WithGRPCConn(conn))
	if err != nil {
		return nil, fmt.Errorf("failed to create OTLP trace exporter: %w", err)
	}

	tracerProvider := trace.NewTracerProvider(
		trace.WithResource(res),
		trace.WithSampler(trace.AlwaysSample()), // Use AlwaysSample for development
		trace.WithBatcher(traceExporter,
			// Default is 5s. Set to 1s for demonstrative purposes.
			trace.WithBatchTimeout(time.Second)),
	)
	return tracerProvider, nil
}

// ⭐️ UPDATED signature to accept context and gRPC connection
func newMeterProvider(ctx context.Context, res *resource.Resource, conn *grpc.ClientConn) (*metric.MeterProvider, error) {
	// ⭐️ OTLP Metric Exporter
	metricExporter, err := otlpmetricgrpc.New(ctx, otlpmetricgrpc.WithGRPCConn(conn))
	if err != nil {
		return nil, fmt.Errorf("failed to create OTLP metric exporter: %w", err)
	}

	meterProvider := metric.NewMeterProvider(
		metric.WithResource(res),
		metric.WithReader(metric.NewPeriodicReader(metricExporter,
			// Default is 1m. Set to 3s for demonstrative purposes.
			metric.WithInterval(3*time.Second))),
	)
	return meterProvider, nil
}

// ⭐️ UPDATED signature to accept context and gRPC connection
func newLoggerProvider(ctx context.Context, res *resource.Resource, conn *grpc.ClientConn) (*log.LoggerProvider, error) {
	// ⭐️ OTLP Log Exporter
	logExporter, err := otlploggrpc.New(ctx, otlploggrpc.WithGRPCConn(conn))
	if err != nil {
		return nil, fmt.Errorf("failed to create OTLP log exporter: %w", err)
	}

	loggerProvider := log.NewLoggerProvider(
		log.WithResource(res),
		log.WithProcessor(log.NewBatchProcessor(logExporter)),
	)
	return loggerProvider, nil
}
```

