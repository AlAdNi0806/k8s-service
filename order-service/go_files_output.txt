/cmd/main.go

```go
// cmd/main.go
package main

import (
	"context"
	"log"
	"os"
	"strings"

	"order-service/internal/config"
	"order-service/internal/handler"
	"order-service/internal/repository"
	"order-service/internal/service"
	"order-service/internal/utils"

	"github.com/go-pg/pg/v10"
	"github.com/labstack/echo/v4"
	echomw "github.com/labstack/echo/v4/middleware"
	"github.com/segmentio/kafka-go"
	"go.opentelemetry.io/contrib/instrumentation/github.com/labstack/echo/otelecho"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
	"go.opentelemetry.io/otel/sdk/resource"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
	semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

func newOTelProvider(ctx context.Context, endpoint string) (*sdktrace.TracerProvider, error) {
	exporter, err := otlptracehttp.New(ctx, otlptracehttp.WithEndpointURL(endpoint))
	if err != nil {
		return nil, err
	}

	tp := sdktrace.NewTracerProvider(
		sdktrace.WithBatcher(exporter),
		sdktrace.WithResource(resource.NewWithAttributes(
			semconv.SchemaURL,
			semconv.ServiceName("order-service"),
		)),
	)
	otel.SetTracerProvider(tp)
	return tp, nil
}

func main() {
	cfg := config.Load()
	utils.InitJWT(cfg.JWTSecret)

	// PostgreSQL
	pgOpts := pg.Options{
		Addr:     cfg.DBHost + ":" + cfg.DBPort,
		User:     cfg.DBUser,
		Password: cfg.DBPassword,
		Database: cfg.DBName,
	}
	db := pg.Connect(&pgOpts)
	defer db.Close()

	// Kafka
	kafkaWriter := &kafka.Writer{
		Addr:         kafka.TCP(cfg.KafkaBrokers...),
		Topic:        "order.created",
		Balancer:     &kafka.LeastBytes{},
		RequiredAcks: kafka.RequireAll,
		Async:        false,
	}
	defer kafkaWriter.Close()

	// Order Service
	orderRepo := repository.NewOrderRepository(db)
	orderService := service.NewOrderService(orderRepo, kafkaWriter)

	// OpenTelemetry
	ctx := context.Background()
	tp, err := newOTelProvider(ctx, cfg.OtelExporterURL)
	if err != nil {
		log.Fatal("Failed to create OTel provider:", err)
	}
	defer func() {
		if err := tp.Shutdown(ctx); err != nil {
			log.Fatal("Failed to shutdown OTel:", err)
		}
	}()

	// Echo
	e := echo.New()

	// Custom logger with IP
	e.Use(echomw.LoggerWithConfig(echomw.LoggerConfig{
		Format: `{"time":"${time_rfc3339}", "method":"${method}", "uri":"${uri}", "status":${status}, "latency":"${latency_human}", "ip":"${remote_ip}"}` + "\n",
	}))
	e.Use(echomw.Recover())

	// OpenTelemetry
	e.Use(otelecho.Middleware("order-service"))

	// Auth middleware
	authMid := func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			authHeader := c.Request().Header.Get("Authorization")
			if authHeader == "" {
				return echo.ErrUnauthorized
			}
			parts := strings.Split(authHeader, " ")
			if len(parts) != 2 || parts[0] != "Bearer" {
				return echo.ErrUnauthorized
			}
			userID, err := orderService.ValidateToken(parts[1])
			if err != nil {
				return echo.ErrUnauthorized
			}
			c.Set("user_id", userID)
			return next(c)
		}
	}

	// Routes
	orderHandler := handler.NewOrderHandler(orderService)
	e.POST("/orders", orderHandler.CreateOrder, authMid)

	// Health check
	e.GET("/health", func(c echo.Context) error {
		return c.JSON(200, map[string]string{"status": "ok"})
	})

	addr := ":8082"
	if port := os.Getenv("PORT"); port != "" {
		addr = ":" + port
	}

	log.Printf("Order service starting on %s", addr)
	log.Fatal(e.Start(addr))
}
```

/internal/config/config.go

```go
// internal/config/config.go
package config

import (
	"os"
	"strings"
)

type Config struct {
	DBHost     string
	DBPort     string
	DBUser     string
	DBPassword string
	DBName     string

	JWTSecret string

	KafkaBrokers []string

	OtelExporterURL string
}

func Load() *Config {
	kafkaBrokers := []string{"localhost:9092"}
	if brokers := os.Getenv("KAFKA_BROKERS"); brokers != "" {
		kafkaBrokers = []string{}
		for _, b := range strings.Split(brokers, ",") {
			kafkaBrokers = append(kafkaBrokers, strings.TrimSpace(b))
		}
	}

	return &Config{
		DBHost:     getEnv("DB_HOST", "localhost"),
		DBPort:     getEnv("DB_PORT", "5432"),
		DBUser:     getEnv("DB_USER", "order_user"),
		DBPassword: getEnv("DB_PASSWORD", "order_pass"),
		DBName:     getEnv("DB_NAME", "order_db"),

		JWTSecret: getEnv("JWT_SECRET", "super-secret-jwt-key"),

		KafkaBrokers: kafkaBrokers,

		OtelExporterURL: getEnv("OTEL_EXPORTER_OTLP_ENDPOINT", "http://localhost:4318"),
	}
}

func getEnv(key, fallback string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return fallback
}
```

/internal/handler/order.go

```go
// internal/handler/order.go
package handler

import (
	"net/http"

	"order-service/internal/service"

	"github.com/labstack/echo/v4"
)

type OrderHandler struct {
	orderService *service.OrderService
}

func NewOrderHandler(orderService *service.OrderService) *OrderHandler {
	return &OrderHandler{orderService: orderService}
}

func (h *OrderHandler) CreateOrder(c echo.Context) error {
	userID, _ := c.Get("user_id").(int64) // можно передавать через контекст в middleware

	type Request struct {
		ProductID int64 `json:"product_id"`
		Quantity  int   `json:"quantity"`
	}

	req := new(Request)
	if err := c.Bind(req); err != nil {
		return echo.ErrBadRequest
	}

	if req.Quantity <= 0 {
		return echo.NewHTTPError(http.StatusBadRequest, "quantity must be positive")
	}

	if err := h.orderService.CreateOrder(c.Request().Context(), userID, req.ProductID, req.Quantity); err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	return c.JSON(http.StatusCreated, map[string]string{"message": "Order created"})
}
```

/internal/middleware/auth.go

```go
// internal/middleware/auth.go
package middleware

import (
	"strings"

	"order-service/internal/service"

	"github.com/labstack/echo/v4"
)

func AuthMiddleware(orderService *service.OrderService) echo.MiddlewareFunc {
	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			authHeader := c.Request().Header.Get("Authorization")
			if authHeader == "" {
				return echo.ErrUnauthorized
			}

			parts := strings.Split(authHeader, " ")
			if len(parts) != 2 || parts[0] != "Bearer" {
				return echo.ErrUnauthorized
			}

			token := parts[1]
			_, err := orderService.ValidateToken(token)
			if err != nil {
				return echo.ErrUnauthorized
			}

			return next(c)
		}
	}
}
```

/internal/model/order.go

```go
// internal/model/order.go
package model

import "time"

type Order struct {
	ID        int64     `pg:"id,pk"`
	UserID    int64     `pg:"user_id,notnull"`
	ProductID int64     `pg:"product_id,notnull"`
	Quantity  int       `pg:"quantity,notnull"`
	Status    string    `pg:"status,default:'pending'"`
	CreatedAt time.Time `pg:"created_at,default:now()"`
}
```

/internal/repository/postgres.go

```go
// internal/repository/postgres.go
package repository

import (
	"context"

	"order-service/internal/model"

	"github.com/go-pg/pg/v10"
)

type OrderRepository struct {
	db *pg.DB
}

func NewOrderRepository(db *pg.DB) *OrderRepository {
	return &OrderRepository{db: db}
}

func (r *OrderRepository) Create(ctx context.Context, order *model.Order) error {
	_, err := r.db.Model(order).Insert()
	return err
}
```

/internal/service/order.go

```go
// internal/service/order.go
package service

import (
	"context"
	"encoding/json"
	"log"

	"order-service/internal/model"
	"order-service/internal/repository"
	"order-service/internal/utils"

	"github.com/segmentio/kafka-go"
)

type OrderService struct {
	orderRepo   *repository.OrderRepository
	kafkaWriter *kafka.Writer
}

type OrderEvent struct {
	OrderID   int64 `json:"order_id"`
	UserID    int64 `json:"user_id"`
	ProductID int64 `json:"product_id"`
	Quantity  int   `json:"quantity"`
}

func NewOrderService(orderRepo *repository.OrderRepository, kafkaWriter *kafka.Writer) *OrderService {
	return &OrderService{orderRepo: orderRepo, kafkaWriter: kafkaWriter}
}

func (s *OrderService) CreateOrder(ctx context.Context, userID, productID int64, quantity int) error {
	order := &model.Order{
		UserID:    userID,
		ProductID: productID,
		Quantity:  quantity,
		Status:    "pending",
	}

	if err := s.orderRepo.Create(ctx, order); err != nil {
		return err
	}

	// Публикуем событие в Kafka
	event := OrderEvent{
		OrderID:   order.ID,
		UserID:    order.UserID,
		ProductID: order.ProductID,
		Quantity:  order.Quantity,
	}

	payload, _ := json.Marshal(event)
	err := s.kafkaWriter.WriteMessages(ctx, kafka.Message{
		Topic: "order.created",
		Value: payload,
	})
	if err != nil {
		log.Printf("Failed to publish to Kafka: %v", err)
		// Можно добавить retry или dead-letter queue в продакшене
	}

	return nil
}

func (s *OrderService) ValidateToken(token string) (int64, error) {
	return utils.ValidateToken(token)
}
```

/internal/utils/jwt.go

```go
// internal/utils/jwt.go
package utils

import (
	"fmt"
	"time"

	"github.com/golang-jwt/jwt/v5"
)

var jwtKey []byte

func InitJWT(secret string) {
	jwtKey = []byte(secret)
}

func ValidateToken(tokenString string) (int64, error) {
	claims := jwt.MapClaims{}
	token, err := jwt.ParseWithClaims(tokenString, claims, func(t *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil || !token.Valid {
		return 0, err
	}

	if exp, ok := claims["exp"].(float64); ok {
		if time.Unix(int64(exp), 0).Before(time.Now()) {
			return 0, fmt.Errorf("token expired")
		}
	}

	if userID, ok := claims["user_id"].(float64); ok {
		return int64(userID), nil
	}
	return 0, fmt.Errorf("invalid user_id in token")
}
```

